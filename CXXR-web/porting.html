<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>C++ R Engine: Porting Guide</title>
  <meta name="generator" content="Amaya 9.54, see http://www.w3.org/Amaya" />
</head>

<body>
<h1>C++ R Engine: Porting Guide</h1>

<p>This document gives guidance on porting R code and C packages to work with
CXXR, and on some coding practices that may affect the portability of CXXR to
different platforms.</p>

<h2>R Code</h2>

<p>In general, if R code behaves differently under CXXR and under CR (in the
release of CR on which this release of CXXR is based), then that is a bug in
CXXR: please report it. However, differences in timing and in space
consumption are to be expected.</p>

<p>Also, there may be differences in the behaviour of R functions which probe
into the implementation of the interpreter. In particular:</p>
<ul>
  <li><code>gc()</code> now returns different quantities, in the form of a
    vector with four rows and two columns: see the revised help page.</li>
  <li>Although <code>mem.limits(nsize, vsize)</code> retains the same
    interface, the interpretation of the quantities involved has changed
    somewhat; likewise the corresponding command-line options to R. See the
    revised Memory help page for details.</li>
  <li>Memory profiling, as accessed <em>via</em> <code>Rprofmem</code> in
    package <code>utils</code>, has not (yet) been properly reengineered for
    CXXR, and the relevant code has not been tested. Do not rely on the
    existing behaviour to persist.</li>
  <li>The function <code>memory.profile()</code> performs no useful function
    in CXXR: it simply returns a vector of zeroes.</li>
  <li>The levels that can be specified with the configuration option
    <code>--with-valgrind-instrumentation</code> have slightly different
    meanings in CXXR: 
    <ol>
      <li>No valgrind-related instrumentation is added to the code.</li>
      <li>Level 1 marks as uninitialized newly-created R data vectors and
        memory blocks allocated from <code>RAllocStack</code> (e.g.
        <code>R_alloc</code> and <code>S_alloc</code> blocks). This level is
        primarily aimed at enabling users of R, including writers of imported
        code (e.g. in C), to detect use of uninitialized data.</li>
      <li>Level 2 marks <em>all</em> memory blocks allocated via
        <code>CXXR::Heap</code> as uninitialized. This, in conjunction with
        the instrumentation that valgrind carries out by default, means that
        pretty well all dynamic memory blocks will be marked as uninitialized
        when they are allocated.</li>
      <li>Level 3 redzones the data blocks allocated via CXXR::Heap. At
        present this is simply a trailing 1-byte redzone. (A
        <strong>redzone</strong> is a small block of memory adjacent to a
        dynamically allocated memory block, to which valgrind forbids read or
        write access; this is used to detect array bound violations.)</li>
    </ol>
  </li>
</ul>

<p>Moreover, while CXXR is at an alpha/beta development stage, internal logic
errors (i.e. errors due to bugs in the interpreter rather than to bugs in the
R code it is interpreting) will sometimes cause the interpreter itself to
terminate, even in circumstances where CR would manage to recover to the
top-level prompt. This is intentional in order to 'preserve the scene of
crime' for debugging.</p>

<h2>C Code</h2>

<h3>Mandatory changes:</h3>
<ul>
  <li><code>R_NilValue</code> in CXXR is simply a null pointer, rather than a
    pointer to a real object. To smooth this change, the following changes
    have been made to accessor functions: 
    <ul>
      <li><code>CAR</code>, <code>CDR</code>, <code>TAG</code> and
        <code>ATTRIB</code> each return a null pointer if passed a null
        pointer.</li>
      <li><code>OBJECT</code> and <code>IS_S4_OBJECT</code> each return
        <code>FALSE</code> if passed a null pointer.</li>
      <li><code>LENGTH</code> and <code>NAMED</code> each return 0 if passed
        a null pointer.</li>
      <li><code>SET_NAMED</code> is a no-op if the first argument is a null
        pointer.</li>
    </ul>
    <p>However, other accessor functions are likely to crash if invoked for
    <code>R_NilValue</code>: the calling code should introduce appropriate
    checks and workarounds.</p>
  </li>
  <li><code>SEXPTYPE</code> is now an enumeration, rather than being
    <code>typedef</code>ed to <code>unsigned int</code>, but the numerical
    values of particular <code>SEXPTYPE</code>s are unchanged. (This change
    appears to have been under comtemplation within CR.) This may necessitate
    some explicit conversions or changes in the types of variables.</li>
  <li>C code that calls (directly or indirectly) certain CXXR internal
    functions that are now implemented in C++ should be compiled in such a
    way that C++ exceptions are propagated correctly. For example, using
    <code>gcc</code> this can be achieved by specifying the compiler flag
    <code>-fexceptions</code>. The most likely case where this will be
    necessary is in code that calls <code>error</code> (aka
    <code>Rf_error</code>); without this change, the R interpreter may not
    return correctly to the top-level R prompt following an error.</li>
  <li>CXXR requires that when <code>UNPROTECT</code> or
    <code>REPROTECT</code> are applied to a pointer, this is carried out in
    the same context (<code>RCNTXT</code>) as that in which the pointer was
    <code>PROTECT</code>ed. This is to help pick up mispairing between
    <code>PROTECT</code> and <code>UNPROTECT</code>.</li>
  <li><code>vmaxget</code> now returns an <code>unsigned int</code> rather
    than <code>void*</code>. Similarly, <code>vmaxset</code> now takes an
    <code>unsigned int</code> as its argument.</li>
  <li>In CR, for historical reasons, <code>R_alloc</code> and kindred
    functions always return a memory block containing at least one more byte
    than the number requested. This cannot be relied upon in CXXR. To
    diagnose problems arising from this, rebuild the program with
    <code>VALGRIND_LEVEL</code> set to 3. Then an extra byte
    <code>will</code> be allocated (not just for R_alloc but for all memory
    allocations <em>via</em> <code>CXXR::Heap</code>), but if the program is
    run under valgrind, any attempt to access this extra byte will be flagged
    as an error.</li>
  <li>In CXXR, <code>VECTOR_ELT</code> and <code>SET_VECTOR_ELT</code> can
    only be applied to <code>SEXP</code>s of type <code>VECSXP</code>
    (implemented internally using class <code>CXXR::ListVector</code>). In
    particular, these functions cannot be applied to <code>EXPRSXP</code>s,
    for which the new functions <code>XVECTOR_ELT</code> and
    <code>SET_XVECTOR_ELT</code> should be used instead..</li>
</ul>

<h3>Suggested changes:</h3>
<ul>
  <li>Redesignate your code as C++ :-) : this will enable more functions to
    be inlined, and open the way to future benefits. At the very least,
    remove features of your code that gratuitously prevent it being compiled
    by a C++ compiler: identifiers called <code>this</code> or
    <code>class</code>, for example. But remember to use <code>extern
    "C"</code> appropriately in your header files, to prevent C++ mangling of
    the names of functions intended to be visible to C code.</li>
  <li>Rework code as necessary to prevent compiler warnings that a
    <code>const</code> qualifier is being discarded.</li>
</ul>

<h2>FORTRAN Code</h2>

<h3>Mandatory changes:</h3>
<ul>
  <li>FORTRAN code that calls (directly or indirectly) certain CXXR internal
    functions that are now implemented in C++ should be compiled in such a
    way that C++ exceptions are propagated correctly. For example, using
    <code>gfortran</code> this can apparently be achieved by specifying the
    compiler flag <code>-fexceptions</code> (though it is not well
    documented). The most likely case where this will be necessary is in code
    that calls <code>rexit</code>; without this change, the R interpreter may
    not return correctly to the top-level R prompt following an error.</li>
</ul>

<h2>C++ Code</h2>

<p>The question of providing additional facilities for external packages
written in C++ has not yet been addressed. In particular, although it is
intended that in the future such packages will be able to make use of the
classes defined in namespace <code>CXXR</code>, the interfaces are in too
much flux at present for this to be advisable.</p>

<p>If you want to help in refactoring of the R interpreter itself, and have
sufficient knowledge of C++, please contact <a
href="mailto:A.R.Runnalls@kent.ac.uk">A.R.Runnalls@kent.ac.uk</a>.</p>

<h2>Porting to Other Platforms</h2>

<p>The following are areas where portability has been traded for efficiency,
simplicity and/or clarity in new code generated for CXXR. There may be other
unportabilities in code inherited from CR.</p>
<ul>
  <li>Constructors of class <code>GCNode</code>, and classes derived from it,
    may rely on the assumption that a null pointer is represented by a zero
    bit pattern. (See <a
    href="http://c-faq.com/null/machexamp.html">http://c-faq.com/null/machexamp.html</a>
    for some machines where this is not true.) This is because they rely on
    the fact that <code>GCNode::operator new</code> zeroes the allocated
    storage, and therefore do not explicitly initialise pointer data members
    if the desired value is a null pointer.</li>
  <li>Using <code>std::list</code>, it is in places (e.g. in garbage
    collection) assumed that if a node is spliced from one list to another,
    an iterator pointing to that node remains valid as an iterator (though it
    is now an iterator within the destination list rather than within the
    source list). This assumption is specifically contrary to ISO14882:1998
    and ISO14882:2003, though it has been identified as a <a
    href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#250">defect</a>
    in the standard.</li>
  <li>In places the CXXR makefiles assume that the following features of GNU
    <code>make</code> are available:
    <ul>
      <li>Appending to <code>make</code> variables using <code>+=</code>.</li>
      <li>Including other files into a makefile using the
        <code>include</code> directive; the included files are remade by make
        automatically if necessary.</li>
    </ul>
  </li>
</ul>
</body>
</html>
