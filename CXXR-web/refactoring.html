<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>C++ R Engine: Refactoring History</title>
  <meta name="generator" content="Amaya 9.54, see http://www.w3.org/Amaya" />
</head>

<body>
<h1>C++ R Engine: Refactoring History</h1>

<p>This document describes the phases within the CXXR project to refactor the
R engine into C++. Each phase is placed within the Subversion
<code>tags</code> directory, with a name of the form <code>0.00-2.5.0</code>,
where <code>0.00</code> indicates the phase, and <code>2.5.0</code> indicates
the R release to which that phase is intended to correspond.</p>

<h2>Phase 0: <code>0.00-2.5.0</code></h2>

<p>In this phase all <code>.cpp</code> files within <code>src/main</code> are
renamed to <code>.cpp</code>, with the following exceptions:</p>
<ul>
  <li><code>complex.c</code>: This file uses the C99 complex types, which are
    not understood by a C++ compiler;</li>
  <li><code>gram.c</code>: This file is automatically generated by
  yacc/bison;</li>
  <li><code>regex.c</code>: The source of this file is very insistent that it
    is C, not C++: it gives a <code>#warning</code> if you attempt to compile
    it with a C++ compiler.</li>
</ul>

<p>The result of this phase does not build correctly; however, it is useful
as a baseline for seeing the subsequent changes.</p>

<h2>Phase 1: <code>0.01-2.5.0</code></h2>

<p>Make such changes to the result of Phase 0 to enable the <code>.cpp</code>
files to compile without warning using <code>-Wall</code> with
<code>gcc-4.1.3</code>, retaining C linkage conventions for everything
defined in <code>.h</code> files. Ensure that the whole of R will build
correctly and pass <code>make check</code>.</p>

<p>A desirable side effect of enforcing C linkage was that the linkage editor
picked up several instances where the source file implementing a function
failed to <code>#include</code> the appropriate header file, and consequently
generated a function with C++ linkage: see below.</p>

<p>This needed to address the following issues:</p>
<ul>
  <li><code>Rboolean</code> is different from C++ <code>bool</code>.
    <code>Rboolean</code> is an enumeration with elements
    <code>FALSE=0</code> and <code>TRUE=1</code>; <code>bool</code> is a
    primitive type, with values <code>false</code> and <code>true</code>.
    (Also, there are <code>#define</code>s of <code>FALSE</code> to 0 and
    TRUE to 1 lurking around in the R code, just to confuse matters.) In
    particular an <code>Rboolean</code> is a different size from a
    <code>bool</code>. It was necessary to introduce many explicit
    conversions from <code>bool</code> (resulting in C++ from evaluating
    Boolean expressions) or integer types to <code>Rboolean</code>. 
    <p>In connection with this, defined a macro <code>RBOOL(x)</code> within
    <code>Rinlinedfuns.h</code> expands to <code>x</code> in C and
    <code>Rboolean(x)</code> in C++.</p>
  </li>
  <li>The C++ keywords <code>class</code>, <code>new</code>,
    <code>private</code> and <code>this</code> were used as identifiers;
    these had to be renamed, e.g. <code>class</code> changed to
    <code>connclass</code>.</li>
  <li>In various places, particularly <code>connections.cpp</code>, a
    <code>void*</code> was implicitly converted to another type of pointer.
    These conversions were made explicit, and flagged
  <code>/*CCAST*/</code>.</li>
  <li><code>datetime.cpp</code> and <code>memory.cpp</code> used statements
    of the form <code>i -= d;</code> where <code>i</code> is of integer type
    and <code>d</code> is an expression evaluating to a floating point type.
    This was converted to the form <code>i = int(i - (d));</code> to avoid a
    compiler warning. This interpretation complies with sec. 6.5.12.2 of the
    C99 standard <a
    href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf">ISO:IEC
    9899:1999</a>.</li>
  <li>The structure type <code>NewDevDesc</code> defined in
    <code>GraphicsDevice.h</code> contains a number of pointers to functions
    as members, and the types of these functions were specified without
    giving the number and types of the function arguments. This was
    rectified. It was also necessary to give this structure a tag
    (<code>_NewDevDesc</code>) because most of these functions included a
    pointer to a <code>NewDevDesc</code> among their arguments.</li>
  <li>It was necessary to shift some of the material in
    <code>R_ext/GraphicsEngine.h</code>, in particular the definition of
    <code>R_GE_context</code>, into a new header file
    <code>R_ext/GraphicsContext.h</code>, to avoid reciprocal dependencies
    between <code>GraphicsEngine.h</code> and
  <code>GraphicsDevice.h</code>.</li>
  <li>The pointer to function type <code>CCODE</code>, defined in
    <code>Defn.h</code>, was redefined to make the number and type of its
    arguments explicit, as follows: 
    <pre>typedef SEXP (*CCODE)(SEXP, SEXP, SEXP, SEXP);</pre>
  </li>
  <li>If <code>__MAIN__</code> is defined, <code>libextern.h</code>
    <code>#define</code>d <code>extern</code> to the empty string, which
    could play havoc with the <code>extern "C"</code> used in C++ to enforce
    C-style linkage. This <code>#define</code> was commented out, and instead
    a new macro <code>extern1</code> was <code>#define</code>d within
    <code>Defn.h</code>.</li>
  <li>In numerous places it was necessary to make conversions from
    floating-point types to integer types explicit. In other places it was
    clear that the same effect could be achieved without deleterious side
    effect by changing the type of a variable.</li>
  <li>It was necessary to introduce <code>reinterpret_cast</code>s in various
    places in <code>memory.cpp</code>, <code>scan.cpp</code>,
    <code>serialize.cpp</code> and <code>vfonts.cpp</code>. (In future it is
    the intention to get rid of as many of these as possible, as well as
    getting rid of all C-style casts.)</li>
  <li>In <code>Defn.h</code>, the whole declaration <code>extern FUNTAB
    R_FunTab[];</code> was made <code>#ifndef __R_Names__</code>, not just
    the word <code>extern</code>.</li>
  <li>In some places I couldn't resist changing the type of a function
    argument from a plain pointer to a <code>const</code> pointer. We can
    expect much more of this later, but this may have been premature.</li>
  <li><code>sysutils.cpp</code> (conditionally) contained an
    <code>extern</code> declaration of <code>environ</code>; the compiler
    considered this to have C++ linkage, conflicting with the C-linkage
    definition in <code>unistd.h</code> (subsequently <code>#include</code>d
    into <code>sysutils.cpp</code>). This <code>extern</code> declaration has
    been itself replaced by a (conditional) <code>#include</code> of
    <code>unistd.h</code>.</li>
  <li>Sorted out problems where a file implementing a function failed to
    include the relevant header file. In some cases this was because the
    prototype didn't appear in <em>any</em> header file, and clients of the
    function were instead relying on a prototype within the client source
    file itself! Such misplaced prototypes were found in
    <code>eval.cpp</code>, <code>format.cpp</code>, <code>memory.cpp</code>,
    <code>platform.cpp</code>, <code>printutils.cpp</code>, and
    <code>library/methods/src/methods_list_dispatch.c</code>; they were
    commented out, and flagged with the comment "Use header files!". Needed
    prototypes that didn't appear in any header file were generally placed at
    the end of <code>Defn.h</code>. 
    <p>A particularly obscure example of this kind concerns
    <code>R_CHAR</code>. This is declared as a pointer to a function in
    <code>Rinternals.h</code>, and implemented in <code>memory.cpp</code>.
    Now <code>memory.cpp</code> does <code>#include</code>
    <code>Rinternals.h</code>, but it does so with
    <code>USE_RINTERNALS</code> defined, as a result of which the
    <code>R_CHAR</code> declaration in the header file isn't seen by the
    compiler, and so the implemented function got C++ linkage. I modified the
    header file by moving the <code>R_CHAR</code> declaration outside the
    <code>#ifndef USE_RINTERNALS</code>.</p>
  </li>
  <li>The definitions in <code>print.cpp</code> of functions intended to be
    called from FORTRAN needed to be surrounded by <code>extern "C"{</code>
    ... <code>}</code>.</li>
  <li><code>deparse.cpp</code>:1191 used <code>&amp;</code> where
    <code>&amp;&amp;</code> was surely intended;
    <code>character.cpp</code>:738 similarly used <code>|</code> instead of
    <code>||</code>.</li>
  <li><code>-Wall</code> complains about attempts to compare signed with
    unsigned. This required explicit conversions in numerous places.
    Generally (but not always) I did this by converting unsigned to signed.
    In other places it was clear that the same effect could be achieved
    without deleterious side effect by changing the type of a variable. 
    <p>In connection with this, the macro <code>AGE_NODE</code> in
    <code>memory.cpp</code> had to be changed to make <code>an__g__</code>
    unsigned.</p>
  </li>
</ul>

<h2>Phase 2: <code>0.02-2.5.0</code></h2>

<p>In a subsequent phases (possibly starting in Phase 3) it is our objective
to replace the SEXPREC union by a hierarchy of C++ classes. This phase
prepares for that by reorganising the material in the header files in
<code>src/include</code>. This involves creating a new subdirectory
<code>src/include/CXXR</code>, and within that creating a new header file
<code>RObject.h</code> (ultimately to include a base class
<code>RObject</code> for the new hierarchy), and further header files
<code>RClosure.h</code>, <code>REnvironment.h</code>,
<code>RInternalFunction.h</code>, <code>RPairList.h</code>,
<code>RPromise.h</code>, <code>RSymbol.h</code> and <code>RVector.h</code>,
corresponding respectively to <code>closxp_struct</code>,
<code>envsxp_struct</code>, <code>primsxp_struct</code>,
<code>listsxp_struct</code>, <code>promsxp_struct</code>,
<code>symsxp_struct</code> and <code>vecsxp_struct</code>, which will
eventually be derived classes. The material in these new headers comes
predominantly from <code>Rinternals.h</code>, but to some extent (in the case
of <code>RInternalFunction.h</code>) from <code>Defn.h</code>. All of the new
header files, with the exception of <code>RInternalFunction.h</code>, are
also installed in <code>$(rincludedir)/CXXR</code>.</p>

<p>Function prototypes moved into the new header files are documented using
<a href="http://www.doxygen.org">doxygen</a>. Where is was clearly consistent
with the semantics, some of the argument types of the functions were changed,
either by adding <code>const</code>, or by converting <code>int</code> into
<code>Rboolean</code> (however, see the issues below regarding the
latter).</p>

<p>The following are implementational details and issues that arose:</p>
<ul>
  <li>The implementation of SEXPREC (though still the unchanged C code) was
    made visible only to C++ programs. This is to get advance warning of
    potential problems when the implementation <em>is</em> changed to
  C++.</li>
  <li>In many places CR defined a name as a macro when
    <code>USE_RINTERNALS</code> was defined, and otherwise as a function. It
    has been the intention in this phase to replace the macros with C++
    inline functions: these would automatically also generate a non-inlined
    form, so the separate definition (usually in <code>memory.cpp</code>)
    could be dispensed with. 
    <p>This was all very well where the function form was implemented in CR
    simply by invoking the macro; however in some cases the function form
    carried out some error checking before invoking the macro. Trying to
    convert the macro to an inline function would then result in two distinct
    functions with the same name, which the compiler and/or linker would
    certainly reject.</p>
    <p>In the end it was decided to leave the macros in place for the time
    being: they'll have to be changed when the C++ implementation rolls out
    anyway.</p>
  </li>
  <li>I considered getting rid of the <code>USE_RINTERNALS</code> compilation
    conditions, but decided to retain it to mark out material (usually
    currently in the form macro definitions) that will in the future need
    privileged access to a C++ class. Only <code>memory.cpp</code> now
    <code>#define</code>s <code>USE_RINTERNALS</code>.</li>
  <li><code>Rinternals.h</code> contained many <code>#define</code>s of
    function names to the same name prefixed by <code>Rf_</code>: this
    appears to correspond in C++ terms to putting these functions in a
    namespace. I split these <code>#define</code>s out into a separate header
    file <code>Rf_namespace.h</code>, which is <code>#include</code>d by
    <code>RObject.h</code> (which is in turn included by the other new
    headers). There are various similar <code>#define</code>s scattered
    around other CR header files, which may need to be moved into
    <code>Rf_namespace.h</code> in due course.</li>
  <li>I dithered about whether to name the file in question
    <code>RInternalFunction.h</code> or <code>RPrimitiveFunction.h</code>.
    Usage in the CR code (e.g. <code>primsxp_struct</code>) suggests the
    latter, and the R Internals document speaks of internal and primitive
    functions as being mutually exclusive, but fails to give a more general
    name covering any function handled via <code>R_FunTab</code>. But it
    seems to be reasonable to regard primitive functions as a special case of
    an internal function, hence the eventual choice of
    <code>RInternalFunction.h</code>.</li>
  <li>It is noted that <code>Rdynload.cpp</code> and <code>dotcode.cpp</code>
    each give compiler warnings under <code>-pedantic</code> because they
    attempt to cast function pointers to <code>void*</code>. The source code
    of the former already contains a comment saying that it's illegal even in
    C. Not easy to fix, so leave for now.</li>
  <li>It seems logical (!) that a logical vector (<code>LGLSXP</code>) should
    contain items of type <code>Rboolean</code> rather than of type
    <code>int</code>, and consequently that the macro/function
    <code>LOGICAL(SEXP)</code> should return <code>Rboolean*</code> rather
    than <code>int*</code>. I made some attempt to do this, but backed out of
    it for the following reasons: 
    <ul>
      <li>The <code>.C</code> interface expects these vectors to contain
        <code>int</code>s;</li>
      <li>ISO14882:1998 says that in C++, subject to certain constraints, it
        is implementation-defined which integral type is used as the
        underlying type for an enumeration (though <code>gcc</code> happens
        to use <code>int</code> for <code>Rboolean</code>).</li>
      <li>ISO9899:1999 says much the same for C, but with differently worded
        constraints.</li>
      <li>In any case, despite the commented-out <code>MAYBE</code> value in
        the enumeration, perhaps <code>Rboolean</code> is best thought of as
        '<code>bool</code> for C', rather than having any capability to
        handle NAs.</li>
    </ul>
    <p>Possible new policy: within functions visible from C, use
    <code>Rboolean</code> as a substitute for C++ <code>bool</code>, possibly
    constrained to be 32 bits long to avoid the <code>enum</code>
    implementation dependencies noted above. However, R logical vectors will
    continue to be represented using <code>int</code>s. (One day we might
    define an <code>Rlogical</code> class - a wrapper round an
    <code>int</code> - to handle logical vectors within C++, while C programs
    simply see <code>typedef int Rlogical;</code>.)</p>
  </li>
</ul>

<h2>Phase 3: <code>0.03-2.5.0</code></h2>

<p>The primary objective of this phase was to redefine
<code>R_NilValue</code> as a null (i.e. zero) pointer of type
<code>SEXP</code>. <code>R_NilValue</code> is widely used within CR as a
stub, i.e. to signify that something that might be present is absent, in much
the same way that a null pointer is used within C or C++. However, in CR it
is actually implemented in effect as an element of a pairlist (i.e.
<code>struct listsxp</code>), whose CAR, CDR, TAG and attributes all point to
itself. This would cause difficulties in CXXR when we reimplement the
<code>SEXPREC</code> union as a type hierarchy, because pairlist elements
will need to be of a specific type within the hierarchy. If
<code>R_NilValue</code> were given this type, it would preclude its use as a
general-purpose stub. But zero is a possible value for a pointer of any type,
so if we equate <code>R_NilValue</code> to zero this will sidestep the
problem.</p>

<p>Another disadvantage of the CR definition of <code>R_NilValue</code> is
that it needlessly introduces a cyclic data structure.</p>

<p>The following are implementational details and issues that arose in
carrying out this change:</p>
<ul>
  <li>The existing code in many places invokes functions/macros
    <code>CAR</code>, <code>CDR</code>, <code>TAG</code> and
    <code>ATTRIB</code> on a <code>SEXP</code> that may in fact be
    <code>R_NilValue</code>, expecting in this case for each of these
    functions to return <code>R_NilValue</code>. These functions were
    reimplemented to preserve this behaviour: i.e. each of them returns a
    null pointer if passed a null pointer. At the same time the macro forms
    were abolished: they are now implemented as inline functions for C++, and
    ordinary functions if called from C.</li>
  <li>In the same spirit, <code>OBJECT</code> and <code>IS_S4_OBJECT</code>
    have been reimplemented to return <code>FALSE</code> if passed a zero
    pointer. They too are now implemented as inline functions for C++, and
    ordinary functions if called from C.</li>
  <li>No such modification was made to <code>NAMED</code>: the policy here is
    that the calling code should be modified as necessary to prevent it being
    invoked for a null pointer. Deal similarly with invocations of
    <code>SET_NAMED</code>, <code>PRINTNAME</code>,
    <code>NODE_IS_MARKED</code>, <code>SET_ATTRIB</code>,
    <code>SET_OBJECT</code>, and <code>LENGTH</code>. (This last case is
    interesting because <code>LENGTH</code> is meant to be applied to vector
    objects, i.e. components of the <code>SEXPREC</code> union different from
    <code>struct listsxp</code>.) The calling sites concerned were determined
    by running <code>make check</code> at top-level: doubtless many have
    slipped through the net!</li>
  <li>Incidental to the above changes, some of the macros in
    <code>memory.cpp</code> were replaced by inline functions.</li>
</ul>

<p>A secondary objective of this phase was to get rid of C-style casts within
the C++ code, wherever the appropriate remedy was reasonably obvious and
straightforward. The following kinds of C-style casts were left in place
pending further work:</p>
<ul>
  <li>Casts from one function pointer type to another (often involving
    <code>DL_FUNC</code>);</li>
  <li>Casts from one struct pointer type to another (often involving
    <code>DevDesc</code> and <code>GEDevDesc</code>);</li>
  <li>Use of the construct <code>(void*)(-1)</code>;</li>
  <li>Casts to/from <code>R_varloc_t</code>;</li>
  <li>Other puzzling casts.</li>
</ul>

<p>Addendum 2007/08/06: although <code>make check</code> works with this
release, <code>make check-devel</code> doesn't.</p>

<h2>Phase 4: <code>0.04-2.5.1</code></h2>

<p>The primary objective of this phase was to update the program to parallel
release 2.5.1 of R. This proved to be straightforward, except that it was
necessary to install a later version of <code>svn_load_dirs.pl</code> to cope
with filenames containing <code>@</code> signs. (However, I was surprised to
discover that <code>svn merge</code> doesn't track renames.)</p>

<p>Other changes were as follows:</p>
<ul>
  <li>Bugs revealed by <code>make check-devel</code> were fixed. In general
    this was done by modifying certain functions to behave reasonably if
    passed a null pointer, namely <code>LENGTH</code> (returns 0),
    <code>NAMED</code> (returns 0) and <code>SET_NAMED</code> (does nothing).
    These changes obviated some of the changes made leading up to svn
    revision 49 (see Phase 3 above), and these changes were accordingly
    reversed. <code>make check-all</code> also now works, but it was
    time-consuming to run and revealed no bugs.</li>
  <li>I managed to get <code>autoconf</code> working properly, and
    accordingly backed out of some configuration kludges I had made
    previously.</li>
</ul>

<h2>Phase 5: <code>0.05-2.5.1</code></h2>

<p>The aim of this phase was to create a branch entitled <code>const</code>,
to explore to what extent the R code is amenable to 'constifying': i.e.
converting pointers and C++ references wherever possible to
<code>const</code> pointers. Two preliminary steps, carried out in the trunk,
were as follows:</p>
<ul>
  <li>In the C++ source files in main, macros were replaced by inline
    functions wherever it was reasonably straightforward to do so. (The
    reason for doing this now was that during the constification process, it
    was usually extremely difficult to see what the compiler was complaining
    about if a multiline macro was involved.) 
    <p>Similar changes were made to the header files under
    <code>src/include</code>: however, the pattern here was to convert a
    macro to an inline function if the header files was
    <code>#include</code>d into a C++ file, and to an out-of-line call to the
    same function if the header file was <code>#include</code>d into a C
    file.</p>
    <p>This macro conversion was counterindicated in the following
    circumstances:</p>
    <ul>
      <li>The body of the macro was not syntactically equivalent to a
        function call;</li>
      <li>The macro used <code>##</code></li>
      <li>The macro modified its arguments, e.g. something like 
        <pre>#define INC(x) ++(x)</pre>
        <p>(Using C++ reference arguments to get round this is not as
        straightforward as it might seem.)</p>
      </li>
      <li>The macro referred to local variables at the point of call
        (although in some cases such macros were converted to inline
        functions with additional arguments);</li>
      <li>In some cases macros were left in place if they expanded to a
        single C/C++ expression or to a single macro invocation: it is the
        multiline macros that are particularly opaque.</li>
    </ul>
  </li>
  <li>An incidental change was this: Until now, the type <code>SEXPREC</code>
    was defined along the following lines: 
    <pre>typedef struct SEXPREC { ... } SEXPREC;</pre>
    <p>with the first occurrence of <code>SEXPREC</code> being what in C
    would have been a structure tag. This has now been changed to:</p>
    <pre>typedef struct RObject { ... } SEXPREC;</pre>
    <p>exploiting the fact that in C++ <code>RObject</code> is a
    fully-fledged class name. The header files in
    <code>src/include/CXXR</code> now generally refer to <code>RObject</code>
    rather than <code>SEXPREC</code>.</p>
  </li>
</ul>

<p>Having established the <code>const</code> branch, constification was set
in train by the brute force measure of redefining <code>SEXP</code> to mean
<code>const RObject*</code> rather than simply <code>RObject*</code>; a new
<code>typedef</code> mapped <code>vSEXP</code> onto plain
<code>RObject*</code>. In the same spirit '<code>v</code>' variants of many
of the accessor functions were introduced: for example now <code>CAR</code>
takes a <code>SEXP</code> argument and returns a <code>SEXP</code>, while
<code>vCAR</code> takes and returns a <code>vSEXP</code>. (Since these
accessor functions are required to be callable from C, we can't simply
overload <code>CAR</code>.)</p>

<p>I then attempted to recompile various files, inserting '<code>v</code>'s
wherever the compiler demanded it. It quickly became apparent that these
'<code>v</code>'s were highly contagious: for example, both
<code>NA_STRING</code> and <code>R_EmptyEnv</code> had to be declared as
<code>vSEXP</code>s rather than <code>SEXP</code>s. This led me to the
conclusion that it was premature to attempt constification until I understand
the evaluation process better.</p>

<p>At the time of tagging this release, the following files compile without
warnings in the <code>const</code> branch: <code>memory.cpp</code>,
<code>envir.cpp</code> and <code>names.cpp</code>. <code>eval.cpp</code>
gives one compilation error, when <code>do_function</code> attempts a
non-const operation on its <code>op</code> argument: fixing this would mean
changing the signature of all the <code>do_</code> functions.</p>

<h2>Phase 6: <code>0.06-2.5.1</code></h2>

<p>In CR, each <code>SEXPREC</code> has a node class in the range 0 to 7.
Nodes of non-vector <code>SEXPTYPE</code> (i.e. not of types
<code>CHARSXP</code>, <code>LGLSXP</code>, <code>INTSXP</code>,
<code>REALSXP</code>, <code>CPLXSXP</code>, <code>STRSXP</code>,
<code>VECSXP</code>, <code>EXPRSXP</code>, <code>WEAKREFSXP</code> or
<code>RAWSXP</code>) are all in class 0, and are 28 bytes long. Class 7 is
used for vector nodes whose vector data amount to more than 128 bytes; the
remaining classes are used for smaller vectors, classified according to their
size. Nodes of class 7 are allocated directly using <code>malloc</code>;
nodes of the remaining classes are allocated from 'pages' about 2 kB in size,
with each node class having its own pages. In CXXR it is intended to replace
<code>SEXPREC</code>s with an extensible class hierarchy (rooted at
<code>RObject</code>), so it will not be feasible to put a tight upper bound
on the size of non-vector nodes.</p>

<p>Another feature of CR is that in vector nodes, a single block of memory
contains the data of the vector preceded by a <code>SEXPREC</code> and
information about the length of the header. This is quite incompatible with
the design philosophy of C++, which is that the size of an object must be
deducible from its (C++) type: in particular <code>::operator delete</code>
relies on this.</p>

<p>The purpose of Phase 6 was to circumvent these problems, and at the same
time to endeavour to decouple the code for allocating memory from the code
managing garbage collection. This comprised the following changes:</p>
<ul>
  <li>A new class <code>CXXR::Heap</code> was created to handle allocation
    and deallocation of blocks of memory. This parallels CR to the extent
    that requests for large blocks are passed on directly to <code>::operator
    new</code>, while requests for small blocks are satisfied by allocating
    fixed-sized cells carved out of 'superblocks'. However, this is an
    implementational detail and is not visible to the remainder of CXXR: only
    the total number of bytes and the total number of blocks allocated
    <em>via</em> <code>CXXR::Heap</code> are visible (using static member
    functions). 
    <p>It is intended that <code>CXXR::Heap</code> will serve as a back-end
    to implementations of operator new and to an STL-compatible Allocator
    class. Note in particular that the blocks allocated from
    <code>CXXR::Heap</code> are not exclusively used to create
    <code>RObject</code>s, but may be used for any purpose where rapid
    allocation/deallocation of small blocks is required.</p>
  </li>
  <li>Node classes have been abolished, and the garbage collector now treats
    all nodes in the same way. In particular, following garbage collection,
    all unused nodes are deallocated back to <code>CXXR::Heap</code>. (CR
    deallocates only large vector nodes.)</li>
  <li>The data of a vector object now resides in a separate block allocated
    from <code>CXXR::Heap</code>; a data member <code>m_data</code> of
    <code>RObject</code> (in due course to be factored out into a derived
    class) points to this block. For non-vector objects, and vectors of size
    zero, <code>m_data</code> is a null pointer. (CR appears to allocate at
    least 8 bytes of vector data even when the nominal size of the vector is
    zero.)</li>
  <li>In CR decisions about when to garbage collect, and how many generations
    to collect are based (a) on the total number of nodes of classes 0-6, and
    (b) the total size of the vector data in nodes of class 7 (reckoned in
    units of 8 bytes). In CXXR the same logic is used, but based (a) on the
    total number of nodes, and (b) the total number of bytes currently
    allocated from <code>CXXR::Heap</code>, divided by 8. 
    <p>I was strongly tempted to base GC exclusively on (b), and to ignore
    the number of nodes - after all, we're talking about a single resource
    here: memory. I'd welcome opinions about this.</p>
  </li>
</ul>

<h2>Phase 7: <code>0.07-2.5.1</code></h2>

<p>The purpose of this phase was to encapsulate all the garbage-collection
logic within C++ classes. Five such classes were introduced, namely
<code>GCManager</code>, <code>GCNode</code>, <code>GCEdge</code>,
<code>GCRoot</code> and <code>WeakRef</code>, as now described.</p>
<ul>
  <li>Class <code>GCManager</code>, as the name implies, carries out
    high-level management of garbage collection. It has no non-static data or
    methods. When <code>CXXR::Heap</code> indicates (<em>via</em> a callback)
    that it is on the point of requesting additional memory from the
    operating system, method <code>GCManager::gc()</code> decides whether to
    carry out a garbage collection, and if so how many generations to
    collect. As comtemplated at tag 0.06-2.5.1, this decision is now based
    only on the total memory allocated <em>via</em> <code>CXXR::Heap</code>,
    and not on the number of nodes allocated. If <code>GCManager</code>
    decides to carry out a garbage collection, this is carried out by calling
    <code>GCNode::gc()</code>, specifying the number of generations to be
    collected.</li>
  <li>Class <code>GCNode</code> is intended to be the base class for all
    objects subject to garbage collection; <code>RObject</code> is now
    derived from <code>GCNode</code>. All <code>GCNode</code>s are threaded
    on circular doubly-linked lists according to their generation, managed
    <em>via</em> the static private vector <code>s_genpeg</code>. Element 0
    of this vector represents the 'new' generation of nodes that have not yet
    been exposed to the garbage collector; nodes that survive garbage
    collection are moved into successively higher generations.</li>
  <li>Templated class <code>GCEdge&lt;T&gt;</code>, where <code>T</code>
    (defaulting to <code>RObject*</code>) is a pointer to a class type
    derived from <code>GCNode</code>, represents a directed edge within the
    directed graph whose nodes are the <code>GCNode</code>s. Whenever an
    object of a type derived from <code>GCNode</code> wishes to refer to
    another such object, it should do so by incorporating a
    <code>GCEdge</code> encapsulating an appropriate pointer, rather than by
    incorporating the pointer directly. The class provides for
    <code>GCEdge&lt;T&gt;</code> to be implicitly converted to <code>T</code>
    in contexts which require this. 
    <p><code>GCEdge</code> contains the logic for ensuring that a node in a
    higher generation never includes a reference to an object in a younger
    generation. If any attempt is made to direct a <code>GCEdge</code> from
    an older node to a younger node, that younger node is immediately
    promoted to the the generation of the older node, and this change is
    propagated through the outgoing <code>GCEdge</code>s of the younger node,
    and so on recursively. (In other words, it implements the
    <code>EXPEL_OLD_TO_NEW</code> logic that can be configured into CR (but
    is not the default for CR).)</p>
  </li>
  <li>Templated class <code>GCRoot&lt;T&gt;</code>, where <code>T</code>
    (defaulting to <code>RObject*</code>) is a pointer to a class type
    derived from <code>GCNode</code>, is intended to protect
    <code>GCNode</code>s from the garbage-collector. A <code>GCNode</code>
    pointed to by a <code>GCRoot</code> will not be garbage collected for as
    long as the <code>GCRoot</code> object exists. The constructor and
    destructor of this class therefore perform similar functions to the
    <code>PROTECT</code>/<code>UNPROTECT</code> macros of CR, but within a
    C++ idiom, in which the programmer is spared the need to check that
    <code>PROTECT</code>s are balanced by <code>UNPROTECT</code>s. (However,
    <code>PROTECT</code> and <code>UNPROTECT</code> continue, and will
    continue, to be available within CXXR.) The class provides for
    <code>GCRoot&lt;T&gt;</code> to be implicitly converted to <code>T</code>
    in contexts which require this. 
    <p>The implementation of <code>GCRoot</code> uses an internal stack, and
    consequently requires (and checks) that <code>GCRoot</code>s are
    destroyed in the reverse order of their creation. This should cause no
    problem as long as only variables with automatic or static storage
    duration are declared as <code>GCRoot</code>s.</p>
    <p>Despite successful experiments, the deployment of this class has been
    deferred, pending the replacement of
    <code>setjmp</code>/<code>longjmp</code> within CXXR by C++ exceptions.
    This is because destructors of C++ automatic variables are not called
    when the stack is unwound by <code>longjmp</code> (see ISO14882:2003 sec.
    18.7); they are when the stack is unwound by a C++ exception.</p>
  </li>
  <li>Class <code>WeakRef</code> implements weak references (<code>SEXPTYPE
    WEAKREFSXP</code>) in a way intended to be functionally identical to CR.
    Each weak reference has a key and, optionally, a value and/or a
    finalizer. The finalizer may either be a C/C++ function or an R object. 
    <p>The garbage collector will consider the value and finalizer to be
    reachable provided the key is reachable. If, during a garbage collection,
    the key is found not to be reachable then the finalizer (if any) will be
    run, and the weak reference object will be 'tombstoned', so that
    subsequent calls to key() and value() will return null pointers. A weak
    reference object with a reachable key will not be garbage collected even
    if the weak reference object is not itself reachable.</p>
    <p>Note that, in CXXR, weak references are not implemented as
    four-element vectors, and the class has separate, appropriately typed
    fields for R and C/C++ finalizers (though at most one of these fields may
    be used in any particular <code>WeakRef</code> object).</p>
  </li>
</ul>

<h2>Phase 8: <code>0.08-2.5.1</code></h2>
<ul>
  <li>All uses of <code>setjmp</code> and <code>longjmp</code> (and
    <code>sigsetjmp</code> and <code>siglongjmp</code>) within directory
    <code>main</code> have been removed, and replaced by using
    <code>JMPException</code>, a C++ exception class designed as far as
    possible to be a drop-in replacement for
    <code>setjmp</code>/<code>longjmp</code>. This is to ensure that the
    destructors of C++ objects are invoked as the stack is unwound following
    an exceptional condition. 
    <p>Use of <code>JMPException</code> should be regarded as an interim
    measure. Normal C++ coding practice is for <code>throw</code> simply to
    report the exceptional condition that has arisen, rather than - as with
    <code>JMPException</code> - in effect requesting a specific subsequent
    flow of control.</p>
  </li>
  <li>The preferred way for C++ code to protect <code>GCNode</code>s from the
    garbage collector is now to use the templated class <code>GCRoot</code>.
    <code>GCRoot</code>'s constructor will protect the <code>GCNode</code> in
    question, and its destructor will unprotect it; there is therefore no
    need for the programmer to remember to balance out the use of
    <code>PROTECT</code> and <code>UNPROTECT</code> as in CR. 
    <p>The facilities of CR's pointer protection stack (using e.g.
    <code>PROTECT</code> and <code>UNPROTECT</code>) remain available, but
    the underlying implementation has been rewritten in C++ as part of the
    <code>GCRootBase</code> class. CXXR makes the additional requirement that
    when <code>UNPROTECT</code> or <code>REPROTECT</code> are applied to a
    pointer, this is carried out in the same context (<code>RCNTXT</code>) as
    that in which the pointer was <code>PROTECT</code>ed. This is to help
    pick up mispairing between <code>PROTECT</code> and
    <code>UNPROTECT</code>.</p>
  </li>
  <li>Various CR header files, particularly <code>Rinternals.h</code> and
    <code>Defn.h</code>, contain macro definitions of the form 
    <pre>#define func Rf_func</pre>
    <p>These serve to avoid name clashes (at least at the linker level) with
    third-party packages; a similar purpose would be achieved in C++ by
    placing the function <code>func</code> in a namespace <code>Rf</code>.
    (In Phase 2 these macros were generally shifted into a separate header
    file <code>Rf_namespace.h</code>, but this change has now been reversed.)
    Using the preprocessor to modify program tokens in this way is something
    that many C++ programs will shun, especially since some of the tokens
    concerned (e.g. <code>length</code>) are likely to be widely used.
    However abolishing these macros altogether would break much existing
    code. Nevertheless, reliance on them is now deprecated within CXXR, and
    in particular all header files within <code>src/include</code> have been
    modified as necessary to include the <code>Rf_</code> prefix explicitly
    where it is needed.</p>
  </li>
</ul>

<h2>Phase 9: <code>0.09-2.6.1</code></h2>

<p>The primary objective of this phase was to update the program to parallel
release 2.6.1 of R.</p>

<p>Other changes were as follows:</p>
<ul>
  <li>In previous work, the tendency has been progressively to <em>move</em>
    function prototypes from CR's header files into the relevant
    class-oriented (or at least data-type-oriented) header files within
    <code>include/CXXR</code>, and at the same time to add doxygen
    documentation. This has now been modified into a policy of
    <em>copying</em> the prototypes into the relevant CXXR header file, and
    adding documentation there, but leaving the prototype also in the CR
    header file. This will make it easier to track changes in function
    signatures when we upgrade to future releases of R. To this end a script
    <a href="src/main/allincludes.pl">allincludes.pl</a> has been produced.
    This generates an (otherwise trivial) C++ source file that
    <code>#include</code>s all the header files under <code>src/main</code>
    and <code>src/include</code>; compiling this file checks that the
    prototypes in the CXXR header files are consistent with those in the CR
    headers.
    <p>In the light of this change, the policy regarding the Rf_ prefix
    described under Phase 8 has been modified. Whilst all header files in the
    <code>CXXR</code> directory should use the Rf_ prefix explicitly, header
    files derived from CR (e.g. <code>Rinternals.h</code> and
    <code>Defn.h</code>) should normally omit the prefix if the corresponding
    CR file does so.</p>
  </li>
  <li>All macros with arguments have been removed from the header files in
    the <code>CXXR</code> directory.</li>
  <li>All C-style casts have been removed from the C++ code. (Unfortunately,
    under some Linuxen at least, standard signals such as
    <code>SGN_DFL</code> are defines as macros in terms of C-style casts, so
    <code>main.cpp</code> still gives warnings if compiled using
    <code>gcc</code> with <code>-Wold-style-cast</code>.)</li>
</ul>
</body>
</html>
